{"name":"svelTest Language Tutorial","tagline":"PLT Spring 2014","body":"svelTest Language Tutorial\r\n=================\r\nThis tutorial will serve as a quick guide for getting svelTest programs up and running. All of the code used throughout the tutorial can be found [here](https://github.com/svelTest/svelTest/tree/master/tutorial).\r\n#Table of Contents\r\n1. [Introduction](#introduction)\r\n2. [Setup](#setup)\r\n3. [Hello World](#hello-world)\r\n4. [File](#file)\r\n5. [Funct](#funct)\r\n<br>&nbsp;&nbsp;&nbsp;&nbsp;5.1 [What the Funct?](#what-the-funct)\r\n6. [I/O](#io)L\r\n<br>&nbsp;&nbsp;&nbsp;&nbsp;6.1 [Input](#input)\r\n<br>&nbsp;&nbsp;&nbsp;&nbsp;6.2 [Output](#output)\r\n<br>&nbsp;&nbsp;&nbsp;&nbsp;6.3 [readlines()](#readlines)\r\n7. [Return & Assert](#return--assert)\r\n<br>&nbsp;&nbsp;&nbsp;&nbsp;7.1 [verbose](#verbose)\r\n8. [Main](#main)\r\n9. [If/Else](#ifelse)\r\n10. [Another Example: Add](#another-example-add)\r\n11. [Arrays](#arrays)\r\n12. [Writing Svelter Code: Looking at Add Again](#writing-svelter-code-looking-at-add-again)\r\n13. [Conclusion](#conclusion)\r\n\r\n# Introduction\r\nThe svelTest Language Tutorial will serve as a quick guide for getting svelTest programs up and running. This guide will go through several major aspects of the svelTest language by looking at various simple examples.\r\n\r\nThe svelTest programming language aims to simplify the complex process of testing production code. Our language targets any programmer looking for a simplified way to test source code to their specifications, in their own environment.\r\n\r\nThe purpose of this tutorial is to introduce the user to the basics of svelTest, allowing them to easily pick up svelTest syntax and code style. These examples concentrate on the basics of the language like variable declaration, arithmetic operations, loading source code files, and manipulating test case output.\r\n\r\nIt is important for the user to understand that this is not a complete tutorial on svelTest. Like any programming language, practice makes a great programmer. For more in-depth information on the intricacies of svelTest, please refer to our [Language Reference Manual](http://sveltest.github.io/manual/).\r\n\r\nRemember to have fun, and you’ll be writing svelte code before you know it!\r\n\r\n# Setup\r\nsvelTest does not require any outside packages or installers. The compiler was developed under Python version 2.7.3, so it will work best with that (but any Python 2.7.x version should be fine). Fire up your favorite text editor and you’re ready to start programming! We do, however, expect if you want to test Java programs that you to have configured your Java environment properly, and can compile and run Java programs from your favorite shell using javac and java respectively.  svelTest currently supports Java SE 6. To check your Java version, type java -version into your shell.  If you see java version \"1.6.0_XX\", you’re in luck! If you see java version 1.7.X or 1.8.X, please make sure to roll back to Java 6. We also support Python 2.7.x and any version of gcc that supports C99; you can perform similar checks for these dependencies. For the rest of this tutorial, we will use Java.\r\n\r\n# Hello World\r\nTo get familiar with svelTest syntax, we can look at the svelTest’s interpretation of Hello World. This program prints “Hello World!” to the console.\r\n\r\n```java\r\n// hello.svel\r\n\r\n// prints \"Hello World!\" to console \r\nlang = None;\r\nmain() {\r\n\tstring hello = \"Hello World!\";\r\n\tprint(hello);\r\n}\r\n```\r\n\r\nEach svelTest program needs a `lang` declaration and a `main` function to run a program. (In this case, since we’re not testing any code, we use the `None` keyword; we’ll discuss lang more in our next example.) Each declaration is ended with a semicolon; whitespace and indentation do not matter to the compiler. To declare an object like a `string` or an `int`, much like Java, you need to first declare the type, then name the object. A string literal is indicated by quotation marks.\r\n\r\n`print` is a reserved word in svelTest that prints to the console.  \r\n\r\nThough `hello.svel` is a valid svelTest program, it does not really show what the language can do. Let’s look at Java’s Hello World. \r\n\r\n\r\n```java\r\n// Hello.java\r\n\r\n// prints \"Hello World!\" to console\r\npublic class Hello {\r\n\tpublic static void main (String args[]) {\r\n\t\tString hello = \"Hello World!\";\r\n\t\tSystem.out.println(hello);\r\n\t}\r\n}\r\n```\r\nA svelTest program to test the output of `Hello.java` (which should be “Hello World!”) would look like this:\r\n\r\n```java\r\n// helloJava.svel\r\n\r\n// tests Hello.java\r\nlang = Java;\r\n\r\nboolean helloWorldTest() {\r\nfile helloFile = \"HelloWorld.java\";\r\nfunct helloMain = {__main__, (j_String[]), helloFile};\r\ninput _in = ();\r\noutput out = \"Hello World!\";\r\n\r\n\treturn helloMain.assert(_in, out);\r\n}\r\n\r\nmain() {\r\n\tif (helloWorldTest()) {\r\n\t\tprint(\"Hello World passed!\");\r\n\t} else {\r\n\t\tprint(\"Hello World failed.\");\r\n\t}\r\n}\r\n```\r\nCompiling your svelTest program is easy. You should have the `lib` folder containing the compile script; let’s say you also have another folder called `tutorial`. (We have this structure on our repo [here](https://github.com/svelTest/svelTest).) Navigate into `lib`, then type:\r\n\r\n\t./compile.sh ../tutorial/helloJava.svel\r\n\r\nThis will produce `helloJava.py` in the testing folder. The `helloJava.py` file does the grunt work of testing and comparing output as well as manipulating that output however you wish. All you have to do is change into the testing directory and run the compiled Python program:\r\n\r\n\tcd ../testing\r\n\tpython helloJava.py\r\n\r\n\r\n####Let’s go through the program line by line, starting with the following:\r\n\r\n\t//tests Hello.java\r\n\r\nComments in svelTest are indicated by a // or  /* ... */ for block comments; comments cannot be nested. The following are all valid comments:\r\n\r\n\t// this is valid\r\n\r\n\t/* this is valid too */\r\n\t\r\n     /* this is \r\n\t  * also valid\r\n\t  */\r\n\r\n`lang`, as we mentioned earlier, is the language specifier.\r\n\t\r\n\tlang = Java;\r\n\r\nIn this case, we’re testing a Java program, so we must specify that `lang` equals `Java`. We also support `Python`, `C`, and `None`. These specifications determine which helper files to import to the compiled code; using `None` can avoid that overhead if it isn’t need.\r\n\r\n\r\n####Next, we have:\r\n\r\n```java\r\nboolean helloWorldTest () {\r\n\t...\r\n}\r\n```\r\n\r\nMethods in svelTest must be declared with their return type; in this case, `helloWorldTest()` returns a `boolean`. Function definitions are enclosed by curly braces. If the svelTest method does not return a value, declare the method with the `void` return type.\r\n\r\nFunctions in svelTest must also be fully defined before they are used. Note that `main()` uses `helloWorldTest()`; if `helloWorldTest()` was not fully defined before `main()`, the compiler would throw an error.\r\n\r\n# File\r\n\r\n\tfile helloFile = \"../Hello.java\";\r\n\r\n`file` is used to select the file you want to test; it is followed by the object name. On the right side of the equals, the name of the file is entered as a string literal. In this case, we’re making a `file` object called `helloFile` and indicating that the `Hello.java` file is one directory above the svelTest program.\r\n\r\n# Funct\r\nThe `funct` type is a wrapper to specify the method to test. \r\n\r\n### What the Funct?\r\nThe `funct` type is easy to use and declare.\r\n\r\n\tfunct helloMain = {__main__, (j_String[]), helloFile};\r\n\r\n`funct` is used to select which method of the file to test. It requires the name of the method, the the formal parameter type(s) of the method (more parameters can be added, separated by commas), and the file containing the method. \r\n\r\n# I/O\r\n### Input\r\n\r\n\tinput _in = ();\r\n\r\n`input` is used to denote the input required by the method being tested. Multiple parameters should be separated by commas.  In this case, it is empty because the main method of `Hello.java` does not take any parameters. Note that we cannot call this input `in` but instead must call it `_in`; this is because `in` is a reserved keyword in svelTest programs. (See our [Language Reference Manual](http://sveltest.github.io/manual/) for a full list of reserved words.)\r\n\r\n# Output\r\n\r\n\toutput out = \"Hello World!\";\r\n\r\n`output` is use to denote the expected output of the method you are testing. An `output` can take the value of any type in the source programming language.\r\n\r\n### readlines()\r\n####While we don’t use `readlines()` in our `helloJava.svel` program, we want to cover it briefly in our discussion of file I/O. \r\nTake a look at the following snippet:\r\n\r\n\tfile outputs = \"outputs.txt\";\r\n\toutput[] out = outputs.readlines();\r\n\r\nThe `file` type has the reserved, built-in function `readlines()` that reads the entire contents of a `file` into a `string` array. (In this case, we can put those results directly into an `output` array, since `output`s take `string`s.) The trailing newline character is stripped from each string as each line is copied to the array. This allows the user to easily load sets of `input`s and `output`s from ASCII text files into string arrays for use in a svelTest program.\t\r\n\r\n# Return & Assert\r\n#### Let’s return to our discussion of `helloJava.svel`.\r\n\r\n\treturn helloMain.assert(_in, out);\r\n\r\nThe `helloWorldTest()` function must return a `boolean`. When the `assert()` function is called on a `funct`, it uses the `input` and `output` parameters to test the method. `assert()` then returns either true or false depending if the expected output matches the method’s standard output. \r\n\r\n### verbose\r\n`assert()` also has an optional third argument, `verbose`. Specifying `verbose` as the third argument adds additional functionality to `assert()`: instead of just returning true or false, `assert()` will also print test information to standard output for you. For example, something like\r\n\r\n\thelloMain.assert(_in, out, verbose);\r\n\r\nwould print\r\n\r\n\tmain()...\t\tPASS\r\n\r\nwithout any additional code.\r\n\r\n# Main\r\n\r\n```java\r\nmain(){\r\n\t...\r\n}\r\n```\r\n\r\nEach svelTest file is required to have a `main` method. It should be at the bottom of the file, after the methods it calls are declared.\r\n\r\n# If/Else\r\n\r\n```java\r\nif (helloWorldTest()) {\r\n\tprint(\"Hello World passed!\");\r\n} else {\r\n\tprint(\"Hello World failed.\");\r\n}\r\n```\r\n\r\nThis is a standard if/else statement that tells the program what to do in case of success or failure. If `helloWorldTest()` returns true (the `assert` test matches), it will print “Hello World passed!” to standard output. If not, it will print “Hello World failed.”\r\n\r\n# Another Example: Add\r\n\r\nConsider the following Java file that contains a method to add two Java integers:\r\n\r\n```java\r\n// Add.java\r\n\r\npublic class Add {\r\n\tpublic static void main(String[] args) {\r\n\t\tint z = add(1, 2);\r\n\t\tSystem.out.println(\"The sum of 1 and 2 is \" + z);\r\n\t}\r\n\r\n\tpublic static int add(int x, int y) {\r\n\t\treturn x + y;\r\n\t}\r\n}\r\n```\r\nSuppose you wanted to make sure that just the function `add()` worked correctly. You want to check multiple cases and track which tests it passes. A svelTest program to test the `add()` function would look like this:\r\n\r\n```java\r\n// add.svel\r\n\r\n// test suite for add function in Add.java\r\nlang = Java;\r\nint addTestSuite() {\r\n\tint addSuccessCounter = 0;\r\n\r\n\t// svelTest test idiom:\r\n\t//\t1. declare a file\r\n\t//\t2. declare a funct (ie: the source program or method to test)\r\n\t//\t3. create input(s) and corresponding output(s)\r\n\t//\t4. call assert() on the funct with the input(s) and output(s)\r\n\t\r\n\tfile addFile = \"Add.java\";\r\n\tfunct add = {\"add\", (j_int, j_int), addFile};\r\n\tinput in1 = (1, 2);\r\n\toutput out1 = 3;\r\n\tinput in2 = (-2, 2);\r\n\toutput out2 = 0;\r\n\tinput[] inArray = {in1, in2};\r\n\toutput[] outArray = {};\r\n\r\n\toutArray.append(out1);\r\n\toutArray.append(out2);\r\n\r\n\tfor(int i = 0; i < inArray.size(); i = i+1) {\r\n\t\tif (add.assert(inArray[i], outArray[i])) {\r\n\t\t\taddSuccessCounter = addSuccessCounter + 1;\r\n\t\t}\r\n\t}\r\n\r\n\treturn addSuccessCounter;\r\n}\r\n\r\nmain() {\r\n\tint successNumber = addTestSuite();\r\n\t\r\n\tif (successNumber == 2) {\r\n\t\tprint(\"2/2 cases are successful\");\r\n\t} else {\r\n\t\tprint(\"method did not work as intended\");\r\n\t}\r\n}\r\n```\r\nThe method `addTestSuite()` is declared with a return type of `int`. It declares an `int` called `addSuccessCounter` and initializes it to zero. It then specifies the location of `Add.java` with a `file` and creates a `funct` to test the `add()` function, which takes two Java integers (`j_int`) as parameters. \r\n\r\n# Arrays\r\nArrays can be instantiated directly or dynamically.\r\n\r\n```java\r\ninput in1 = (1, 2);\r\noutput out1 = 3;\r\ninput in2 = (-2, 2);\r\noutput out2 = 0;\r\ninput[] inArray = {in1, in2};\r\noutput[] outArray = {};\r\noutArray.append(out1);\r\noutArray.append(out2);\r\n```\r\n\r\nIn this section we create two `input`s that have two `int`s enclosed in parentheses and separated by commas. We also make two corresponding `output`s. The following lines show how to add objects to arrays. In the input array, we add the already created objects to `inArray` in the same line as the declaration. In the output array, we declare the array and use `append()` to add the two `output`s to the end of the array. Note that we must initialize `outArray` as empty with curly brackets in order to append or insert values into it.\r\n\r\n```java\r\nfor(int i = 0; i < inArray.size(); i++) {\r\n\t\tif (add.assert(inArray[i], outArray[i])) {\r\n\t\taddSuccessCounter++;\r\n\t}\r\n}\r\n```\r\n\r\nsvelTest supports `for` loops that have 3 parameters: one that initializes a counter, a boolean expression, and an incrementer. This boolean expression uses `size()` to compare `i` with the number of elements in the array. The `for` loop contains an `if` statement to check each element of the `input` array against the corresponding element with the same index of the `output` array. If the test evaluates as true, `addSuccessCounter` will increment. \r\n\r\nThe end of the method returns `addSuccessCounter`.\r\n\r\nThe `main` method of this .svel file runs `addTestSuite()` and prints out that the cases were successful if it passed two out of two tests.\r\n\r\nA last note on arrays: Other supported array functions are `remove()`, `insert()`, `size()`, and `replace()`. The prototypes are outlined below:\r\n\r\n* `a.remove(int index)` \r\n* `a.insert(int index, object o)`\r\n* `a.size()`\r\n* `a.replace(int index, object o)`\r\n\r\n# Writing Svelter Code: Looking at Add Again\r\nYou might notice that our `add.svel` program looks a little bulky: only 10 lines of Java code to test led to over 40 lines of svelTest code. The `add.svel` program was intentionally written to be very clear, but a lot of the idioms can be condensed. Take a look at our svelter version:\r\n\r\n```java\r\n// addSvelter.svel\r\n\r\n// more succinct test suite for add function in Add.java\r\nlang = Java;\r\n\r\nmain() {\r\n\tfunct add = {\"add\", (j_int, j_int), \"Add.java\"};\r\n\tinput[] inArray = {(1,2), (-2,2), (4, 5)};\r\n\toutput[] outArray = {3, 0, 10};\r\n\r\n\t// the third test case should fail (4+5 != 10)\r\n\tfor(int i = 0; i < inArray.size(); i = i+1) {\r\n\t\tadd.assert(inArray[i], outArray[i], verbose);\r\n\t}\r\n}\r\n```\r\n\r\nHopefully you can convince yourself that you’ll see the following output:\r\n\r\n\tadd(1, 2)... \t\t\t\t\t PASS\r\n\tadd(-2, 2)... \t\t\t\t\t PASS\r\n\tadd(4, 5)... \t\t\t\t\t FAIL\r\n\t\treturned: 9\r\n\t\texpected: 10\r\n\r\nIf you don’t believe us, give it a try yourself! As you can see, only 10 lines of code now successfully run three test cases.\r\n\r\n\r\n# Conclusion\r\n\r\nThis Language Tutorial covers the basic capabilities of the svelTest programming language. We hope that this tutorial will be useful in assisting users in writing their own, more complex, testing programs. Although we only used Java in this tutorial, writing your own svelTest programs to test C and Python should be nearly identical, but check out the Reference Manual for more extensive discussion. As stated previously, please see our [Language Reference Manual](http://sveltest.github.io/manual/) for a more comprehensive analysis of the features of svelTest.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}